// Name: Bruno
// Last name: Vandekerkhove
// Student number: s0216676

vocabulary V_fixed {
    type X isa int
    type Y isa int
    type Number isa int
    type Pos constructed from { P(X, Y) }
    land(Pos)
    water(Pos)
    islandSize(Pos, Number)
}

vocabulary V_student {
    extern vocabulary V_fixed
    onIsland(Pos,Pos) // Denotes a position (indirectly) connected to a numbered cell.
    sea(Pos) // Denotes a position that's part of the sea.
}

theory T : V_student {
    
    // Inductive definition of islands.
    //	(1) Numbered cells are part of an island.
    //	(2) All land (indirectly) connected to an island is part of that island.
    {
    	!i,n: onIsland(i,i) <- islandSize(i,n).
    	!i,x,y: onIsland(i,P(x,y)) <- 
        	?a,b: onIsland(i,P(a,b)) & land(P(x,y)) & (abs(x-a) + abs(y-b) = 1).
    }
    
    // Inductive definition of sea.
    //	(1) Take top left cell with water as the base case.
    //	(2) Any cell connected to that cell is part of the sea.
    {
        !x,y: sea(P(x,y)) <- 
        	water(P(x,y)) 
        	& (~?s,t: water(P(s,t)) & s < x) 
        	& (~?z: water(P(x,z)) & z < y).
        !x,y: sea(P(x,y)) <- 
        	?a,b:sea(P(a,b)) & water(P(x,y)) & (abs(x-a) + abs(y-b) = 1).
    }
   
    // Every piece of land is part of exactly one island.
    !p: land(p) <=> ?1i:onIsland(i,p).
    
    // Each island should have the right size.
    !i,n: islandSize(i,n) => #{p[Pos]: onIsland(i,p)} = n.
    
    // Everything is either land or water (exclusive or).
    !p: (land(p) | water(p)) & (~land(p) | ~water(p)).
    
    // A sea cannot contain a 2x2 square.
    ~?x,y: water(P(x,y)) & water(P(x+1,y)) & water(P(x,y+1)) & water(P(x+1,y+1)).
        
    // All water is part of the sea.
    !p: water(p) => sea(p).
    
}

procedure main() {
    model = onemodel(T, S10, V_fixed)
    initVisualization()
    visualizeNurikabe(model)
    printmodels(modelexpand(T,S2,V_student))
}

include "visualize_nurikabe.idp"
include "nurikabe_structures.idp"