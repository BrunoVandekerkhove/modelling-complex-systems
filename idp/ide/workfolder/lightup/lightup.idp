// Name: Bruno
// Last name: Vandekerkhove
// Student number: s0216676

vocabulary V_fixed {
    type X isa int
    type Y isa int
    type Number isa int
    type Pos constructed from { P(X, Y) }
    wall(Pos)
    lamp(Pos)
    lit(Pos)
    tip(Pos, Number)
}

vocabulary V_student {
    extern vocabulary V_fixed
    // add new vocabulary symbols here
    // comment each symbol with intended meaning
    adjacent(Pos,Pos)
    blocked(Pos,Pos)
}

theory T : V_student {
    
    // to be filled in
    // comment each rule  
    
    // Two positions are adjacent iff they neighbor each other.
    {
        !a,b,y: adjacent(P(a,y),P(b,y)) <- (b = a+1 | b = a-1).
        !x,a,b: adjacent(P(x,a),P(x,b)) <- (b = a+1 | b = a-1).
    }
        
    // Walls cannot have any lamps.
    !x[Pos]: wall(x) => ~lamp(x).
    
    // The number of lamps adjacent to walls matches the tips on those walls (if any).
    !w,n: tip(w,n) => #{l[Pos]: lamp(l) & adjacent(l,w)} = n.
    
    // Two positions are blocked if there's a wall between them.
    {
        !a,b,y: blocked(P(a,y),P(b,y)) <- ?w: wall(P(w,y)) & (a =< w =< b | b =< w =< a).
        !x,a,b: blocked(P(x,a),P(x,b)) <- ?w: wall(P(x,w)) & (a =< w =< b | b =< w =< a).
    }
    
    // A position is lit if there's a lamp in the same row or column which is not
    //	blocked by a wall.
    !a,b: lit(P(a,b)) <=> ?c,d:lamp(P(c,d)) & (a = c | b = d) & ~blocked(P(a,b),P(c,d)).
    
    // All cells without walls should be lit.
    !x: ~wall(x) => lit(x).
    
}

// For testing purposes (minimising number of lamps)
term MinimizeLamps : V_fixed { #{p: lamp(p)} }
vocabulary OutputVocabulary { extern V_fixed::lamp/1 
}
procedure main_student() {
    printmodels(minimize(T, S5, MinimizeLamps, OutputVocabulary))
}

// Main procedure
procedure main() {
    model = onemodel(T, S5, V_fixed)
    initVisualization()
    visualizeLightUp(model)
}

include "visualize_lightup.idp"
include "lightup_structures.idp"