// Name: Bruno
// Last name: Vandekerkhove
// Student number: s0216676

vocabulary V_fixed {
    type Station
    type Train
    type Pass isa int
    type Stop isa int
    type Prize isa int
    type Age isa int
    type TicketType constructed from { Standard, Youth, Senior }
    type Ticket constructed from { T(TicketType, Train, Station, Station) }
    track(Station, Station)
    passes(Train, Station, Pass)
    stopsAt(Train, Station, Stop)
    hasTicket(Ticket)
    paid(Ticket, Prize)
    start : Station
    end : Station
    age : Age
}

vocabulary V_student {
    extern vocabulary V_fixed
    requiredType: TicketType // The required ticket type for the passenger.
    reaches(Station) // Passenger stops in this station.
}

theory T : V_student {
    
    // Acquired tickets should be of the right type (based on the passenger's age).
    requiredType = Youth & age < 26 
    	| requiredType = Senior & age > 65 
    	| requiredType = Standard & 26 =< age =< 65.
    !tt,t,s1,s2: hasTicket(T(tt,t,s1,s2)) => tt = requiredType.
    
    // If a train passes at s2 right after s1 then there should 
    //	be a corresponding track.
    !t,s1,s2,p: passes(t,s1,p) & passes(t,s2,p+1) => track(s1,s2).

    // The passes and stops should conform to the specification.
    !t,s2,p: passes(t,s2,p) & Pass(p-1) => ?s1: passes(t,s1,p-1).
    !t,s2,st: stopsAt(t,s2,st) & Stop(st-1) => ?s1: stopsAt(t,s1,st-1).
    
    // The price of a ticket should correspond to the specification.
    {
        !t,s1,s2:paid(T(Youth,t,s1,s2),5) <- hasTicket(T(Youth,t,s1,s2)).
        !t,s1,s2:paid(T(Senior,t,s1,s2),6) <- hasTicket(T(Senior,t,s1,s2)).
        !t,s1,s2,p1,p2:paid(T(Standard,t,s1,s2),3*abs(p2-p1)) <- 
        	hasTicket(T(Standard,t,s1,s2)) & passes(t,s1,p1) & passes(t,s2,p2).
    }
    
    // If a passenger has a ticket the very train should pass at the very stations.
    !tt,t,s1,s2: hasTicket(T(tt,t,s1,s2)) 
    	=> ?p1,p2: stopsAt(t,s1,p1) & stopsAt(t,s2,p2) & p2 > p1.
    
    // The passenger is able to travel from the start to the end.
    {
		reaches(start).
        !s,e: reaches(e) <- reaches(s) & ?tt,t:hasTicket(T(tt,t,s,e)).
		//!s,e: reaches(e) <- reaches(s) & 
        //	?tt,t,a,b,x,y:hasTicket(T(tt,t,a,b)) & stopsAt(t,a,x) & stopsAt(t,b,y) & 
        //	?ss:(stopsAt(t,s,ss) & y >= ss >= x & ?se:stopsAt(t,e,se) & y >= se > ss).
	}
	reaches(end).
    
    // There are no two different tickets for the same train.
    !t:?=<1tt,s1,s2: hasTicket(T(tt,t,s1,s2)).
    
}

// For testing purposes (minimising number of lamps)
term MinimizePrice : V_fixed { sum{t,p: paid(t,p): p} }

procedure main() {
    // model = onemodel(T, S1, V_student)
    stdoptions.nbmodels = 3
	//This should fail, only one should be obtained.
	printmodels(modelexpand(T, S1, V_student))
    // printmodels(minimize(T, S1, MinimizePrice, V_student))
}

include "traintickets_structures.idp"